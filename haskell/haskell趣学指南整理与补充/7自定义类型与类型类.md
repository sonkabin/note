# 构造自己的类型与类型类

## 入门

如何构造自己的类型呢？一种方法是使用`data`关键字，**类型名和值构造子的首字母必大写**

1. Bool的定义：`data Bool = True | False`

2. 自定义一个图形类型，可以是圆形或矩形

   ```haskell
   -- Circle的值构造子有三个项(field)，都是Float。类型是Shape。deriving (Show)表示派生于Show，从而可以打印到ghci中
   data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
   -- 注意：这里的项，其实是参数，值构造子的本质是函数，也就是说可以不全调用
   > :t Circle
   Circle :: Float -> Float -> Float -> Shape
   > :t True
   True :: Bool
   ```

   

3. 定义函数计算图形面积

   ```haskell
   area :: Shape -> Float
   area (Circle _ _ r) = pi * r ^ 2
   area (Rectangle x1 y1 x2 y2) = (abs $ x1 - x2) * (abs $ y1 - y2)
   ```

4. 由于值构造子的本质，可以用map来构造同一个圆心，不同半径的圆

   ```haskell
   > map (Circle 3 5) [1,2,3]
   [Circle 3.0 5.0 1.0,Circle 3.0 5.0 2.0,Circle 3.0 5.0 3.0]
   ```

5. 增加Point类型，使Shape更容易理解

   ```haskell
   data Point = Point Float Float deriving(Show)
   data Shape = Circle Point Float | Rectangle Point Point  deriving(Show)
   area :: Shape -> Float
   area (Circle _ r) = pi * r ^ 2
   area (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x1 - x2) * (abs $ y1 - y2)
   ```

   

6. 移动图形的函数

   ```haskell
   move :: Shape -> Float -> Float -> Shape
   move (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r
   -- 注意这里的括号，不要被弄得眼花缭乱
   move (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point(x2+a) (y2+b))
   -- 定义两个辅助函数
   baseCircle :: Float -> Shape
   baseCircle = Circle (Point 0 0)
   baseRectangle :: Float -> Float -> Shape
   baseRectangle x y = Rectangle (Point 0 0) (Point x y)
   > move (baseRectangle 40 100) 60 23
   Rectangle (Point 60.0 23.0) (Point 100.0 123.0)
   ```

   

7. 将这里定义的所有函数和类型都导出到一个模组中

   ```haskell
   module Shapes
   ( Point(..)
   , Shape(..)
   , area
   , move
   , baseCircle
   , baseRectangle
   ) where
   -- 一个Shape (..)，我们就导出了Shape的所有值构造子,这与写Shape(Rectangle,Circle) 等价
   -- 默认是全部导出的吧....如何import不知道
   ```

   

## Record Syntax

```haskell
data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)

> Car {company="Ford", model="Musting", year=1987}
Car {company = "Ford", model = "Musting", year = 1987}
```



## 类型构造子

注意：不要在data声明中加类型约束，只能在函数中添加类型约束

**=左边的是类型构造子，右边是值构造子**

```haskell
data Vector a = Vector a a a deriving (Show)
vplus :: (Num t) => Vector t -> Vector t -> Vector t
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)
vectMut :: (Num t) => Vector t -> t -> Vector t
(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)

> Vector 3 5 8 `vplus` Vector 9 2 8
Vector 12 7 16
> Vector 3 9 7 `vectMult` 10
Vector 30 90 70
```



## Derived instances

所谓类型类，是描述数据类型的行为。若一个类可以判断相等性，则它是Eq类型类的实例，若一个类可以比较大小，则它是Ord类型类的实例

```haskell
-- Nothing是Maybe a的实例。read可以带参数的类型，但必须填满所有的参数
read "Nothing" :: Maybe Int
read "Just 'a'" :: Maybe Char
```

```haskell
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Sarturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)

-- 是Eq和Ord类型类的成员
> Sunday == Monday
False
> Sunday > Monday
True

-- 是Show和Read类型类的成员
> show Sunday
"Sunday"
> read "Friday" :: Day
Friday

-- 是Bounded类型类的成员
> minBound :: Day
Monday

-- 是Enum类型类的成员
> [Thursday .. ] -- 必须要有空格，不然报错，而[1..]却是正确的
[Thursday,Friday,Sarturday,Sunday]
```

## 类型别名

emmmmm，暂时放过它

简单用法

```haskell
type String = [Char]
```

## 递归定义数据结构

List就是一个递归定义的数据结构

## 类型类定义

`class`关键字