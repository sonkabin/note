# 高阶函数

## Curried functions

**Haskell的所有函数都只有一个参数**，而先前有的多个参数的函数都是Curried functions

### 为什么用箭头来分隔参数和返回值？

这是高阶函数的一个特点，因为高阶函数可以作为参数和返回值传来传去，下面以max为例说明

```haskell
-- max函数类型 max :: (Ord a) => a -> a -> a
-- 也可以写作 max :: (Ord a) => a -> (a -> a)，读作：max取一个参数，并返回一个类型为(Ord a) => a -> a的函数，这个返回的函数取一个a类型的参数，并返回一个a，这就是为什么用箭头来分隔参数和返回值
```

### 不全调用

```haskell
-- 定义一个与100比较的函数
compareWithHundred :: (Num a, Ord a) => a -> a -> Ordering
compareWithHundred x = compare 100 x
-- 改成不全调用形式
compareWithHundred :: (Num a, Ord a) => a -> Ordering
compareWithHundred = compare 100
-- 解释：compare的类型为(Ord a) => a -> a -> Ording，因此用100调用它后返回的函数类型为(Ord a) => a -> Ording，而这正是我们所要的
```

中缀函数也可以不全调用，用括号把它和一边的参数括在一起

```haskell
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
-- 调用divideByTen 200 就是 (/10) 200，等价于 200 / 10
isUppercase :: Char -> Bool
isUppercase = (`elem` ['A'..'Z'])
-- 调用isUppercase 'A'返回True
```

## 开始高阶函数

函数可以取另一个函数作为参数

```haskell
applyTwice :: (a -> a) -> a -> a
appliTwice f x = f (f x)
-- 这里的括号是必须的，表示首个参数是参数与返回值都为a的函数
```

实现zipWith函数

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
-- 首个参数是函数，取两个参数交叉处理，二三个参数是List，返回值为List。第一个List的类型是a，第二个List的类型是b（当然给它传入a类型也没问题）。取List1和List2的首个元素，将f应用于两个元素，继而取List剩余的元素。
-- 使用: zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
-- 结果：[[3,4,6],[9,20,30],[10,12,12]]
-- 解释：传入函数zipWith' (*)，第一步取[1,2,3], [3,2,2]，即变为zipWith' (*) [1,2,3] [3,2,2]，故结果为[3,4,6]；其他类似。
```

