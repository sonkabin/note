# 区间DP

## [acwing:石子合并](https://www.acwing.com/problem/content/284/)

题意：将N堆石子合并成一堆，每次只能合并相邻的两堆石子，合并的代价是两堆石子的质量之和，总的代价最小为多少。

**状态表示**：f[L, R]

- 集合：所有将[L, R]之间的石子合并成一堆的方案的集合
- 属性：min

**状态计算**：

对于$f[L, R] = f[L, k] + f[k + 1, R] + S_R - S_{L-1}$（k取值范围是[L, R - 1]，因为是合并两堆）

**区间DP套路**：先枚举区间长度，再枚举左端点，接着枚举分界点

## [acwing:多边形](https://www.acwing.com/problem/content/285/)

题意：给N个顶点N条边的多边形，每个顶点上有一个数，每条边上有一个运算符（`+或×`），第一步选择一条边然后删除它，之后选择一条边，将其两端点做运算之后值作为新的顶点。最高得分是多少。

**技巧**：断环成链，即`1~N`, `2~N, 1`, ..., `N-1, N, ..., N-2`

**状态表示**：f[L, R], g[L, R]

- 集合：所有将[L, R]合并成一个点的合并方案的集合
- 属性：max(f), min(g)

**状态计算**：

- 对于`+`，f[L, R] = f[L, k] + f[k + 1, R], g[L, R] = g[L, k] + [k + 1, R]（其中k取值范围[L, R-1]）
- 对于`*`，分析情况有9种：
  - k的左边：1）最大值为正、最小值为正；2）最大值为正，最小值为负；3）最大值为负，最小值为负
  - k的右边：1）最大值为正、最小值为正；2）最大值为正，最小值为负；3）最大值为负，最小值为负
  - 因此对于不同的情形，f和g要分别找到对应的关系进行计算。**但是实际上**，有左边的最大最小值minL, maxL, minR, maxR，对应相乘，最大值等于4种结果中的最大值，最小值等于4种结果中的最小值

## [acwing:金字塔](https://www.acwing.com/problem/content/286/)

题意：金字塔是树形的结构，从根节点开始进行DFS遍历，每条边都会被遍历两次，每进入一个节点都会记录，根据记录的结果计算有多少种可能的树形能得到该结果。

**状态表示**：f[L, R]

- 集合：所有DFS序列是str[L, R]的树的集合
- 属性：集合中元素的个数

**状态计算**：

最后一个状态是取最后一棵子树，因此我们枚举k（取值范围为[L, R-2]，步长为2，因为[L, k]与[k, R]必须都为奇数，才可能是一个合法的序列，此外，要枚举k，前提是str[L] == str[R]，且合法序列必须是str[L] == str[k]且str[k] == str[R]，因为从哪进就从哪出），f[L, R] = f[L, k] × f[k + 1, R - 1]



