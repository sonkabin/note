# 复杂度分析

C++大概是1s～2s（Java也类似），也就是说$操作次数 \le 10^8$

```
n <= 30 => 指数型   dfs+剪枝
n = 100 => O(N^3)  图论中的floyd
n = 1000 => O(N^2), O(N^2 logN)
n = 10^4 => O(N * sqrt(N))
n = 10^5 => O(NlogN) 各种sort，线段树、树状数组、set/map、heap、dijkstra+heap、spfa、凸包、半平面交、二分
n = 10^6 => O(N), O(NlogN) hash、双指针、kmp、AC自动机、常数比较小的NlogN的算法：除了线段树和set/map、线性筛素数
n = 10^7 => O(N) 		   双指针、kmp、AC自动机
n = 10^9 => O(sqrt(N))
n = 10^18 => O(logN)	最大公约数、数论
```

## dp复杂度分析

两种方式：1）循环个数；2）状态总数×转移的复杂度，比如打家劫舍I，状态总数为O(N)，转移复杂度O(1)，最终复杂度为O(N)；戳气球，状态总数O(N^2)，转移复杂度O(N)，最终复杂度为O(N^3)。该方法主要适合分析用记忆化搜索解决的问题