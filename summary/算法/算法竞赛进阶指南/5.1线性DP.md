# DP问题

**当某种思路能解决DP时，可以优化的只可能是空间而不是时间，能否优化看状态计算依赖什么**

## 闫氏DP分析法

**核心**：从集合的角度分析DP问题

DP分为两部分：

1. 状态表示

   - 集合：方案数
   - 属性：count、max、min

2. 状态计算

   根据状态来划分集合，从不同的状态开始。划分规则：不重不漏

### [acwing:杨老师的照相排列](https://www.acwing.com/problem/content/273/)

题意：按身高排队，每排人数小于等于后一排人数，大于等于前一排人数。每排排头到排尾身高是单调递减的，同一列中最后一排到第一排身高单调递减，最多有5排，有多少种方案数。

**状态表示**：f[a, b, c, d, e]

- 集合：以最后一排作为第一排，第一排有a个人，第二排有b个人，第三排有c个人，第四排有d个人，第五排有e个人的方案数
- 属性：count

**状态计算**：安排最后一个人是不同状态的开始，根据最后一个人的安排方式，集合可以划分为5个，分别是安排在第一排、第二排、第三排、第四排、第五排，因此f[a, b, c, d, e] = f[a - 1, b, c, d, e] + f[a, b - 1, c, d, e] + f[a, b, c - 1, d, e] + f[a, b, c, d - 1, e] + f[a, b, c, d, e - 1]

### [acwing:最长公共上升子序列](https://www.acwing.com/problem/content/274/)

题意：给定两个长度分别为M和N的字符串A、B，求A、B所有的公共上升子序列中最长的长度

**状态表示**：f[i, j]

- 集合：所有在A[1...i]中和B[1...j]中出现过，且以B[j]结尾的公共上升子序列的集合
- 属性：max

**状态计算**：

- A[i]不包含在公共子序列中：即所有在A[1...i-1]到B[1...j]中出现的公共上升子序列，f[i, j] = f[i - 1, j]
- A[i]包含在公共子序列中：如果A[i] != B[j]则不存在，其实就是第一种；若A[i] == B[j]，需要再次划分多个集合，B[1...N]（N=0, 1, 2, ..., j - 1），即f[i, j] = max(f[i - 1, 0], f[i - 1, 1], ..., f[i - 1, j - 1]) + 1

### [acwing:移动服务](https://www.acwing.com/problem/content/276/)

题意：有三个移动服务员，有多个位置，某个位置有请求则需要派一个服务员过去（有花费），一个时刻只能移动一个服务员，且每个位置只能有一个服务员。计算最小花费。

#### 状态转移方式

1. 用其依赖的状态来更新当前状态（填表，pull方式）
2. 用当前状态更新依赖于它的状态（刷表，push方式）
3. 两种方式一般是等价的，常用第一种，但有时候第二种比较方便（比如这题，当前状态依赖于未知的多个状态，而依赖于它的状态的只有3个）

**状态表示**：f[i, x, y]

- 集合：已经处理完前i个请求，其他两个服务员在x、y两地的安排方案的集合
- 属性：路线花费之和的最小值

**状态计算**：

设z = p[i]

1. 派z去：f[i + 1, x, y] = f[i, x, y] + w\[z\]\[p[i + 1]\]
2. 派x去：f[i + 1, z, y] = f[i, x, y] + w\[x\]\[p[i + 1]\]
3. 派y去：f[i + 1, x, z] = f[i, x, y] + w\[y\]\[p[i + 1]\]

初始状态：p[0] = 3, f[0, 1, 2] = 0（p[0]也可取1或2，p[0] = 1则f[0, 2, 3] = 0；p[0]=2则f[0, 1, 3] = 0）

最终状态：f[n, x, y]

### [acwing:传纸条](https://www.acwing.com/problem/content/277/)

题意：从(1,1)到(m,n)，只能往右走或往下走，选择两条路径，每个路径点上的值只能使用一次（用过一次后不能再次使用该值），求两条路径之和的最大值

**状态表示**：f[x1, y1, x2, y2]（第一条走到x1/y1，第二条走到x2/y2），可以用更简单的状态，f[k, x1, x2]

- 集合：所有第一条路线从(1, 1)走到(x1, k - x1)，第二条路线从(1, 1)走到(x2, k - x2)的路线组合的集合
- 属性：max

**状态计算**：

最后状态是f[k, x1, x2]

- 第一条路线往右走，第二条路线往右走：f[k - 1, x1 - 1, x2 - 1]（即从(1, 1)走到(x1 - 1, k - x1)，(1, 1)走到(x2 - 1, k - x2)）+ (if x1 == x2 : 0 else : val(x1, k - x1) + val(x2, k - x2))。**这里和视频讲解中记录的不一样，可能是我错了**
- 第一条路线往右走，第二条路线往下走：f[k - 1, x1 - 1, x2]（即从(1, 1)走到(x1 - 1, k - x1)，(1, 1)走到(x2, k - 1 - x2)）+ (if x1 == x2 : 0 else val(x1, k - x1) + val(x2, k - x2))
- 第一条路线往下走，第二条路线往右走：同理
- 第一条路线往下走，第二条路线往下走：同理

### [acwing:分饼干](https://www.acwing.com/problem/content/279/)

题意：M块饼干分给N个小朋友，每个小朋友有贪婪度g[i]，如果有a[i]个小朋友拿到的饼干比第i个小朋友拿到的饼干多，会产生g[i]×a[i]的怨气。安排一种方式，使得每个小朋友至少分到一块饼干，且总怨气最小。

**前置知识**：

排序不等式

如果有两组数$a_1 \le _2 \le ... \le a_n和b_1 \le b_2 \le ... \le b_n$，和的最大值为$\sum_{i=1}^n a_i * b_i$，和的最小值为$\sum_{i=1}^n a_i * b_{n - i + 1}$，用反证法可以证明

**先给小朋友的贪婪度排序**

**状态表示**：f[i, j]

- 集合：所有前i个小朋友分配j块饼干的方案的集合
- 属性：min

**状态计算**：

这个状态计算有点难想

f[i, j]可以划分为0个小朋友分到1块饼干，1个小朋友分到1块饼干, ..., i个小朋友分到1块饼干。以中间的状态来考虑，有k个小朋友分到1块饼干，此时的怨气为$(g[i - k + 1] + ... + g[i]) * (i - k) + f[i - k, j - k]$；另外还有0个小朋友分到1块饼干的状态，该状态需要特别考虑，因为小朋友的怨气值和分到的饼干数量多少无关，因此让每个小朋友都减少1块饼干，结果不会变化，因此有$f[i, j] = f[i, j - i]$

