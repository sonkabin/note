# DP问题

## 闫氏DP分析法

**核心**：从集合的角度分析DP问题

DP分为两部分：

1. 状态表示

   - 集合：方案数
   - 属性：count、max、min

2. 状态计算

   根据状态来划分集合，从不同的状态开始。划分规则：不重不漏

### [acwing:杨老师的照相排列](https://www.acwing.com/problem/content/273/)

题意：按身高排队，每排人数小于等于后一排人数，大于等于前一排人数。每排排头到排尾身高是单调递减的，同一列中最后一排到第一排身高单调递减，最多有5排，有多少种方案数。

**状态表示**：f[a, b, c, d, e]

- 集合：以最后一排作为第一排，第一排有a个人，第二排有b个人，第三排有c个人，第四排有d个人，第五排有e个人的方案数
- 属性：count

**状态计算**：安排最后一个人是不同状态的开始，根据最后一个人的安排方式，集合可以划分为5个，分别是安排在第一排、第二排、第三排、第四排、第五排，因此f[a, b, c, d, e] = f[a - 1, b, c, d, e] + f[a, b - 1, c, d, e] + f[a, b, c - 1, d, e] + f[a, b, c, d - 1, e] + f[a, b, c, d, e - 1]

### [acwing:最长公共上升子序列](https://www.acwing.com/problem/content/274/)

题意：给定两个长度分别为M和N的字符串A、B，求A、B所有的公共上升子序列中最长的长度

**状态表示**：f[i, j]

- 集合：所有在A[1...i]中和B[1...j]中出现过，且以B[j]结尾的公共上升子序列的集合
- 属性：max

**状态计算**：

- A[i]不包含在公共子序列中：即所有在A[1...i-1]到B[1...j]中出现的公共上升子序列，f[i, j] = f[i - 1, j]
- A[i]包含在公共子序列中：如果A[i] != B[j]则不存在，其实就是第一种；若A[i] == B[j]，需要再次划分多个集合，B[1...N]（N=0, 1, 2, ..., j - 1），即f[i, j] = max(f[i - 1, 0], f[i - 1, 1], ..., f[i - 1, j - 1]) + 1

### [移动服务](https://www.acwing.com/problem/content/276/)

题意：有三个移动服务员，有多个位置，某个位置有请求则需要派一个服务员过去（有花费），一个时刻只能移动一个服务员，且每个位置只能有一个服务员。计算最小花费。

#### 状态转移方式

1. 用其依赖的状态来更新当前状态（填表，pull方式）
2. 用当前状态更新依赖于它的状态（刷表，push方式）
3. 两种方式一般是等价的，常用第一种，但有时候第二种比较方便（比如这题，当前状态依赖于未知的多个状态，而依赖于它的状态的只有3个）

**状态表示**：f[i, x, y]

- 集合：已经处理完前i个请求，其他两个服务员在x、y两地的安排方案的集合
- 属性：路线花费之和的最小值

**状态计算**：

设z = p[i]

1. 派z去：f[i + 1, x, y] = f[i, x, y] + w\[z\]\[p[i + 1]\]
2. 派x去：f[i + 1, z, y] = f[i, x, y] + w\[x\]\[p[i + 1]\]
3. 派y去：f[i + 1, x, z] = f[i, x, y] + w\[y\]\[p[i + 1]\]

初始状态：p[0] = 3, f[0, 1, 2] = 0（p[0]也可取1或2，p[0] = 1则f[0, 2, 3] = 0；p[0]=2则f[0, 1, 3] = 0）

最终状态：f[n, x, y]

