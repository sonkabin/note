# 倍增

## 问题引入

给一个长度为N 的数列A(每个数都为非负整数)，然后进行若干次询问，每次给一个整数T，求出最大的k，满足$\sum_{i=1}^k \le T_k$，（算法必须即时回答每一个询问，而不能等待收到所有的询问后再统一处理），假设$0 \le T \le \sum_{i=1}^kA[i]$ 

### 解法一：暴力

枚举每个位置，直到不满足条件

### 解法二：前缀和+二分

预处理O(N)，二分O(logN)。但是二分的缺点在于无论T为多少，二分操作都会执行logN次。因此当T比较小（且查询多次）、N比较大时，可能解法一比解法二还要快

### 解法三：倍增

步骤：

1. 判断$A_1 \le T$是否成立，若是，则进入第二步
2. 判断$A_1 + A_2 + A_3 \le T$是否成立，若是，则进入第三步
3. 判断$A_1 + ... + A_7 \le T$是否成立，若是，依次类推（**步长成倍增长**）
4. 当不成立时，折半缩小步长，即尝试缩小步长为$2^{k-1}, ... , 2, 1$ 

k<=logN，且k的大小与T的大小成正比，因此最坏情况也就是二分的情况

## ST算法

ST算法是倍增的产物QAQ，RMQ（区间最值问题）可由ST算法解决。

### 举例

给定一个长度为N的数列A，ST算法能在O(NlogN)的预处理后，以O(1)的时间复杂度**在线回答**“数列A中下标在l～r之间的数的最大值是多少”这样的区间问题。

**如何解决呢？**

用$f[i,j]$表示从i开始，长度为$2^j$这个区间的最大值，递推公式为$f[i][j] = max(f[i][j-1], f[i + 2^{j-1}][j - 1])$，即取左右两半部分子区间的最大值。因为区间重合不会影响最大值（而有些问题区间重合会影响结果），所有对于[l,r]区间的最大值，让k满足$\frac {r - l + 1}{2} \le 2^k \le r-l+1$ ，可取max(f\[i\]\[k\], f\[r - 2^k + 1\]\[k\])

![06倍增ST算法最大值](img/06倍增ST算法最大值.jpg)

