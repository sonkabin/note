# 背包问题

## [自然数拆分](https://www.acwing.com/problem/content/281/)

题意：给一个自然数N，把N拆成若干个正整数相加的形式，参与加法运算的数可以重复，拆分方案数是多少。拆分方案不考虑顺序且至少拆成2个数的和

该问题等价于完全背包问题，一个数可以取无限次，问某个数可以由小于它的数组成的方案数

**状态表示**：f[i, j]

- 集合：前i个数恰好能凑出j的方案数
- 属性：count

**状态计算**：

- 不取第i个数，方案数为f[i - 1, j]

- 取第i个数，分别是取1次，取2次，...，取k次，因此方案数为

  $f[i, j] = f[i - 1, j - v_i] + f[i - 1, j - 2*v_i] + ... + f[i - 1, k*v_i]$

- 优化：

  $f[i, j] = f[i - 1, j] + 取第i个数,而f[i, j - v_i] = f[i - 1, j - v_i] + f[i - 1, j - 2*v_i] + ... + f[i - 1][j - k*v_k]$，因此$f[i, j] = f[i - 1, j] + f[i, j - v_i]$。**注意**$f[i, j - v_i]$依赖于前面的状态，因此j要从小到大遍历

## [陪审团](https://www.acwing.com/problem/content/282/)

题意：N个人中选M个人，每个人有两个分数p[i]和d[i]（分数在0～20之间），选出的M个人满足总分P和D的差的绝对值最小，选择方案不唯一时，选择P+D最大的方案。M的范围是1～20

由M的范围可以知道，差值的范围是[-400, 400]，因此可以先枚举差值为0，若不存在则枚举差值为-1、1，依次类推，这样能保证选的是绝对值最小，从而就可以设计状态表示了

**状态表示**：f[i, j, k]

- 集合：所有从前i个人中选择j个人，且差值是k的所有方案的集合
- 属性：max

**状态计算**：

- 不选第i个人，则`f[i, j, k] = f[i - 1, j, k]`
- 选第i个人，$f[i, j, k] = f[i - 1, j - 1, k - (p_i - d_i)] + p_i + d_i$

**补充**：如何从最终的结果推断出DP每一步所作的选择？

从终态开始，先判断是否选了第i个人（即`f[i, j, k] == f[i - 1, j, k]`），如果没选则i--；如果选了，则记录答案，并且`i--, j--，k -= (p - d)`

