# RMQ(ST表)

区间最值查询（静态的）

思路：令f[i, j]表示从i开始，长度为$2^j$区间的最值。假设我们要求最大值，则`f[i, j] = max(f[i, j - 1], f[i + 2^(j - 1), j - 1])`；查询时，假设要求区间[l, r]之间的最大值v，区间长度`len = r - l + 1`，现在就是找到尽可能大的一个k，使$2^k \le len$成立，因此有$2^{k+1} > len$，也就是说两段k必然能覆盖区间[l, r]，`v = max(f[l, k], f[r - 2^k + 1, k])`

细节：

1. 是`f[r - 2^k + 1, k]`，因为包括右端点的$2^k$个，则左端点要加1。
2. `f[i, j]`的区间长度为$2^j$，故区间为$[i, i + 2^j - 1]$

时间复杂度：预处理O(NlogN)，查询O(1)

## [天才的记忆](https://www.acwing.com/problem/content/1275/)

```c++
#include<iostream>
#include<cmath>
using namespace std;
// 为什么开18？因为两段17能覆盖2e5的长度
const int N = 2e5 + 5, M = 18;
int n, m;
int f[N][M], w[N];

void init(){
    for(int j = 0; j < M; j++)
        // 为什么是i + (1 << j) - 1呢？因为区间是[i, i + 2^j - 1]
        for(int i = 1; i + (1 << j) - 1 <= n; i++)
            if(!j)  f[i][j] = w[i];
            else    f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
}

int query(int l, int r){
    int len = r - l + 1;
    int k = log(len) / log(2);
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)  scanf("%d", &w[i]);
    init();
    scanf("%d", &m);
    while(m--){
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", query(l, r));
    }
    return 0;
}
```

