## [颜色分类](https://leetcode-cn.com/problems/sort-colors/)

荷兰国旗问题，由此引入的基于最优熵的快速排序

```
当数组有多个重复元素时，普通的快排交换次数过多，因此提出的方法
思想：
维护三个指针lt, i, gt：其中[0, lt]中的元素小于v, [lt, gt]中的元素等于v，[gt, len]中的元素大于v。一开始由i来维护，即[lt, i]中的元素等于v, [i, gt]中的元素待确定，只要当i == gt时，就有了上面的结果
```



## [最短管道距离](http://hihocoder.com/problemset/problem/1931)：中位数

找一个数，使得该数到其他所有数的距离和最小
$$
对于一个有限数列x_1, x_2, ..., x_n，中位数使得f(x) = |x - x_1| + |x - x_2| + ... + |x - x_n|取得最小值
$$
[证明：中位数的性质](https://zhuanlan.zhihu.com/p/73139689)

奇数个数取中间的数就行了，而偶数个数时，取中间两数的平均数或者中间两数的任意一个都可以（因为只有两个数时，取两个数的之间的任意一点都不会影响f(x)的值）



## [火星人](https://www.acwing.com/problem/content/description/422/)：全排列

如何从当前的全排列生成下一个比它大且字典序最小的全排列？

字典序要最小，要找到一个可以调换顺序的点，应逆序查找可行的点（想一想为什么不能顺序查找？），该点位置记为k，k一定满足k+1~n的点是单调递减的。

下一步从单调递减的数里找到一个位置t，使得`a[t] > a[k] > a[t + 1]`，交换t与k，得到的k+1～n的点仍然满足单调递减，把其改为升序后就能得到结果

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 10010;
int n, m;
int a[N];

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++)  scanf("%d", &a[i]);
    
    while(m--){
        // next_permutation的实现
        int k = n - 2;
        while(a[k] > a[k + 1])  k--;
        // 第一对正序
        int t = n - 1;
        while(a[k] > a[t])  t--;
        swap(a[k], a[t]);
        reverse(a + k + 1, a + n);
    }
    
    for(int i = 0; i < n; i++)  printf("%d ", a[i]);
    puts("");
    return 0;
}
```



类似的题，限制更多[下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length, k = n - 2;
        // 可能出现重复的数，且可能完全逆序
        while(k >= 0 && nums[k] >= nums[k + 1])  k--;
        if(k >= 0){
            int t = n - 1;
            while(nums[k] >= nums[t])    t--;
            swap(nums, k, t);
        }
        reverse(nums, k + 1, n - 1);
    }
    private void swap(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
    private void reverse(int[] nums, int i, int j){
        while(i < j){
            swap(nums, i, j);
            i++;
            j--;
        }
    }
}
```



### 补充：康托展开

定义：设有n个数（1, 2, 3,..., n），可以有n!种排列方式，康托展开表示的是，在全排列中， 比当前排列组合小的个数

公式：$X = a[n] * (n - 1)! + a[n - 1] * (n - 2)! + ... + a[1] * 0!$，其中a[i]表示的是在a[i]之后，小于a[i]的数有几个



| 排列 | 名次X | 康托展开           |
| ---- | ----- | :----------------- |
| 123  | 1     | 0×2! + 0×1! + 0×0! |
| 132  | 2     | 0×2! + 1×1! + 0×0! |
| 213  | 3     | 1×2! + 0×1! + 0×0! |
| 231  | 4     | 1×2! + 1×1! + 0×0! |
| 312  | 5     | 2×2! + 0×1! + 0×0! |
| 321  | 6     | 2×2! + 1×1! + 0×0! |

例：（1, 2, 3, 4, 5）的排列中，计算34152的康托展开值

1. 小于3的有2个，故有2×4!
2. 小于4的有2个，故有2×3!
3. 小于1的有0个，故有0×2!
4. 小于5的有1个，故有1×1!
5. 小于2的有0个，故有0×0!

说明比34152小的排列有61个，34152**排名**62

### 补充：逆康托展开

现在依据62来倒退34152。

首先**排名62，先减去1**

1. `61 / (4!) = 2余13 `，说明比首位小的数有2个，故首位为3
2. `13 / (3!) = 2余1`，说明比第二位小的数有2个，故第二位为4
3. `1 / (2!) = 0余1`，说明比第三位小的数有0个，故第三位为1
4. `1 / (1!) = 1余0`，说明比第四位小的数有1个，故第三位为5
5. 剩下的最后一位数是2

可以这么做的原因：`a * 0! + b * 1! + c * 2! + d * 3! + e * 4! = X`，则`X / (4!) = e 且 x % (4!) = a * 0! + b * 1! + c * 2! + d * 3!`

#### [排列序列](https://leetcode-cn.com/problems/permutation-sequence/)

#### [Cow Line](https://www.luogu.com.cn/problem/P3014)

```c++
#include <iostream>
#include <cstring>
using namespace std;
typedef long long LL;

const int N = 21;
int n, T;
int a[N];
LL fact[N], m;
char s[3];
bool st[N];

LL cantor(){
    LL res = 0;
    for(int i = 0, k = n - 1; i < n; i++, k--){
        int cnt = 0;
        for(int j = i + 1; j < n; j++)
            if(a[i] > a[j]) cnt++;
        res += fact[k] * cnt;
    }
    return res + 1;
}

void decantor(){
    memset(st, 0, sizeof st);
    m--;
    for(int i = 0, k = n - 1; i < n; i++, k--){
        int t = m / fact[k];
        for(int j = 1; j <= n; j++)
            if(!st[j]){
                if(!t){
                    a[i] = j;
                    st[j] = true;
                    break;
                }
                t--;
            }
        m %= fact[k];
    }
}

int main(){
    cin >> n >> T;
    // 阶乘
    fact[0] = 1;
    for(int i = 1; i < n; i++)  fact[i] = fact[i - 1] * i;

    while(T--){
        cin >> s;
        if(s[0] == 'P'){
            cin >> m;
            decantor();
            for(int i = 0; i < n; i++)  cout << a[i] << " ";
            cout << endl;
        }else{
            for(int i = 0; i < n; i++)  cin >> a[i];
            cout << cantor() << endl;
        }
    }
    return 0;
}
```





## [星空之夜](https://www.acwing.com/problem/content/1404/)：形状的hash方式

思路：用欧几里德距离来唯一确定星群。

```c++
#include<iostream>
#include<cmath>
using namespace std;
typedef pair<int, int> PII;

const int N = 110;
const double eps = 1e-6;
int n, m;
char g[N][N];
PII q[N * N];
int idx;

void dfs(int x, int y){
    g[x][y] = '0';
    q[idx++] = {x, y};
    for(int i = x - 1; i <= x + 1; i++)
        for(int j = y - 1; j <= y + 1; j++){
            if(i == x && j == y)    continue;
            if(i >= 0 && i < n && j >= 0 && j < m && g[i][j] == '1')
                dfs(i, j);
        }
}

double distance(PII x, PII y){
    int dx = x.first - y.first;
    int dy = x.second - y.second;
    return sqrt(dx * dx + dy * dy);
}

double get_hash(){
    double res = 0;
    for(int i = 0; i < idx; i++)
        for(int j = i + 1; j < idx; j++)
            res += distance(q[i], q[j]);
    return res;
}

char get_char(double hash){
    static double map[30];
    static int id = 0;
    for(int i = 0; i < id; i++){
        if(fabs(map[i] - hash) < eps)
            return 'a' + i;
    }
    map[id++] = hash;
    return 'a' + id - 1;
}

int main(){
    cin >> m >> n;
    for(int i = 0; i < n; i++)  cin >> g[i];
    
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(g[i][j] == '1'){
                idx = 0;
                dfs(i, j);
                char c = get_char(get_hash());
                for(int k = 0; k < idx; k++){
                    int x = q[k].first, y = q[k].second;
                    g[x][y] = c;
                }
            }
            
    for(int i = 0; i < n; i++)  cout << g[i] << endl;
    return 0;
}
```



## [最大的和](https://www.acwing.com/problem/content/128/)：二维矩阵边界枚举

```c++
#include<iostream>
using namespace std;

const int N = 110;
int n;
int g[N][N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++){
            cin >> g[i][j];
            g[i][j] += g[i - 1][j]; // 列的前缀和
        }
        
    int res = -1e9;
    for(int i = 1; i <= n; i++) // 按行枚举，枚举开始行
        for(int j = i; j <= n; j++){ // 枚举结束行
            int last = 0;
            for(int k = 1; k <= n; k++){
                last = max(last, 0) + g[j][k] - g[i - 1][k];
                res = max(res, last);
            }
        }
    
    cout << res << endl;
    return 0;
}
```



