# 整理

## 数据结构

### 布隆过滤器

是一种比较巧妙的概率型数据结构，特点是高效地插入和查询，用来告诉你 **“某样东西一定不存在或者可能存在”**。

1. 优点：高效、占用空间小
2. 缺点：返回的结果是概率性的，而不是确切的

#### 应用场景

1. 利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在，就不必进行后续的昂贵查询请求，类似的有 MurmurHash、Fnv 

2. 大value拆分

   Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。

   拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。

#### [整理](数据结构和算法/BitMap.md)

#### 参考资料

[详解布隆过滤器的原理，使用场景和注意事项](<https://zhuanlan.zhihu.com/p/43263751>)

[Java面试中常用的BitMap代码](<https://www.jianshu.com/p/9e7f8f33a61a>)

### 并查集

[整理](数据结构和算法/并查集.md)

### 树状数组

[整理](数据结构和算法/树状数组.md)

### 单调栈

[整理](数据结构和算法/单调栈.md)

### 单调队列

[待整理]()

### 单词查找树

[整理](数据结构和算法/单词查找树.md)



## 算法

### 前缀和

[整理](数据结构和算法/前缀和.md)

### 第K大的数

[整理](数据结构和算法/第K大的数.md)

### KMP算法

[整理](数据结构和算法/KMP算法.md)

### 快速幂

[整理](数据结构和算法/快速幂.md)

## 数学

### 对数公式

换底公式： $log_{a}b = \frac{log_{c} b} {log_{c} a}$ ，证明 $log_a b = \frac{log_a b * log_c a} {log_c a} = \frac{log_c a^{log_a b}} {log_c a} = \frac{log_c b} {log_c a}$ . 

$log_{a}b * log_{b}a = 1$ ，证明 $log_a b * log_b a = \frac{log_b b} {log_b a} * log_b a = 1$. 

### gcd & lcm

两个整数的最大公约数等于其较小的那个数和两数相除的余数的最大公约数，即`gcd(a, b) = gcd(b, a mod b), a > b`，当余数为0时，当前式子的除数即为最大公约数。时间复杂度O(logN)

证明：`a = kb+r，即r = a mod b, r = a - kb`，假设d是a, b的最大公约数，则有`r/d = a/d - kb/d，而a/d-kb/d为整数，故d也是r的公约数，也就是说d是a mod b的公约数，由此可知gcd(a,b) = gcd(b, a mod b)`。通俗的证明，d是a和b的公约数，则d是`ax + by`的公约数，而r = a - yb，故d也是r的公约数

```java
/*
预处理：
if(b > a){
    a ^= b;
    b ^= a;
    a ^= b;
}
*/
int gcd(int a, int b){
    return b == 0 ？ a : gcd(b, a % b);
}
int lcm(int a, int b){
    return a / gcd(a, b) * b;
}
```

### 同余定理

若整数a、b满足(a-b)能被正整数m整除，则称a、b同余，记作 $a \equiv b (mod\ m)$，从另一方面来看，即 $a \mod m \equiv b \mod m$ 

[取余规则](数学/取余规则.md)

### 抽屉原理（鸽巢原理）

1. 第一抽屉原理：

   - 把多于n+1个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件
   - 多于m×n+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体
   - 把无穷多件物体放入n个抽屉，则至少有一个抽屉里有无穷个物体

2. 第二抽屉原理

   把（m×n-1）个物体放入n个抽屉中，其中必有一个抽屉中至多有（m-1）个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)

3. 构造抽屉的方法

   运用抽屉原理的核心是分析清楚问题中，哪个是物件，哪个是抽屉。例如，属相是有12个，那么任意37个人中，至少有几个人属相相同呢？这时将属相看成12个抽屉，则一个抽屉中有 37/12，即3余1，余数不考虑，而向上考虑取整数，所以这里是3+1=4个人，但这里需要注意的是，前面的余数1和这里加上的1是不一样的。因此，**在问题中，较多的一方就是物件，较少的一方就是抽屉**，比如上述问题中的属相12个，就是对应抽屉，37个人就是对应物件，因为37相对12多

4. [参考：抽屉原理（鸽巢原理）](https://blog.csdn.net/Destinymiao/article/details/81392751)

5. [整理](数学/抽屉原理.md)

### 等概率映射

[整理](数学/等概率映射.md)

## 其他

### 尾递归

精髓是**通过参数传递结果，达到不压栈的目的**

#### 尾递归的原理

当编译器检测到一个函数调用是尾递归的时候，它就**覆盖当前的活动记录**而不是在栈中去创建一个新的。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。

1. 递归形式的阶乘

   ```java
   public int fact(int n){
       if(n < 0)	return 0;
       if(n == 0 || n == 1)	return 1;
       return n * fact(n - 1);
   }
   ```

2. 尾递归形式的阶乘

   ```java
   public int facttail(int n, int res){
       if(n < 0)	return 0;
       if(n == 0)	return 1;
       if(n == 1)	return res;
       return facttail(n - 1, n * res);
   }
   ```

3. 分析

   代码1，每次函数调用计算n \* (n-1)!，然后让n=n-1，直到n=1，因为每次函数调用都依赖于用n乘以下一个函数调用的返回值，所以每次堆栈都要保存这次的结果直到下一个函数返回

   代码2，当n==1时直接返回res，而不是返回让前一个函数处理

4. 对于函数式编程来说，由于没有for、while，因此无法写出循环，而直接使用递归需要更多的空间，因此若使用尾递归，编译器将会将源码编译成循环形式。也就是说尾递归可以从循环转化过来。

   **把循环改成尾递归，有一个通用的技巧**，那就是把循环的写法中，需要使用变量的地方，都改成递归参数。在计算时需要使用的变量并不会变少，但我们却不再操心变量的赋值。

   [pow实现(使用快速幂的尾递归或循环)](<https://leetcode-cn.com/problems/powx-n/>)

#### 参考资料

[递归和尾递归的区别和原理](https://blog.csdn.net/zcyzsy/article/details/77151709)

[尾递归优化](<https://zhuanlan.zhihu.com/p/24305359>)

### 位运算

[整理](数据结构和算法/位运算.md)

## 小技巧

### 二维坐标转化为整数

坐标(x, y)，x和y的范围都是[0, 1e9]，则可以存放在一个long的整数中。如果有多个坐标，想要判断某个坐标在不在这些坐标中，可以用到该技巧

```java
Set<Long> set = new HashSet<>();
for(int[] point : points)	set.add((long)point[0] << 30 | point[1]);
if(set.contains((long)judgePoint[0] << 30 | judgePoint[1]))	return true;
return false;
```

根据范围判断需要多少位2进制数

```java
System.out.println(Math.log10(1e9 + 1) / Math.log10(2)); // 求[0,1e9]需要多少位二进制
// 原理是2^n >= x，即n >= log2(x)，但由于没有log2函数，需要用到换底公式
```

